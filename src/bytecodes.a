;; Little Smalltalk bytecodes
;; from Budd 1983, Little Smalltak v4
	!cpu 65816

	;; RA scratch $00
	;; RB -> code literals $04
	;; RC -> method args, temps $08
	;; RD -> instance vars $0C
	;; RS -> interpreter stack pointer $10
	;; RW -> current bytecode $14
	RIV = $10
	RCA = $14
	RCT = $16
	RCC = $18
	NEXTPROC = $0E
BCTAB:
	!word BC_EXTD		;; 00
	!word BC_IVAR
	!word BC_ARG
	!word BC_TVAR
	!word BC_LITERAL	;; 04
	!word BC_CONSTANT
	!word BCIVAR_
	!word BCTVAR_
	!word BC_MARK		;; 08
	!word BC_SEND
	!word BC_SEND1
	!word BC_SEND2
	!word BC_PUSHBLOCK	;; 0C
	!word BC_PRIMITIVE
	!word BC0E
	!word BC_SPECIAL

;; current instruction is in RW $14
BCMASK:
	!word %0000000011110000
BVMASK:
	!word %0000000000001111
RAMASK: !word $00FF

	* = $F800
BCDO:			;; take next bytecode
			;; (bytecode nextbyte -- codeptr value)
	+short		;; is this process runnable?
	LDA #$01
	BIT $0C
	BEQ BCNEXT

	+long
	LDA (RW)
	AND BCMASK
	BNE +		;; is it EXTD?
	LDA (RW)	;; bytecode is AL value is B
	XBA
	AND RAMASK
	PHA		;; push 8 bit 'value'
	LDA (RW)
	+incr RW	;; skip value byte
	AND BVMASK
	ASL		;; *2 produces the table offset
	BRA .EXTD

+	LDA (RW)	;; bytecode is AH value is AL
	AND BVMASK
	PHA		;; push 4 bit 'value'

	LDA (RW)
	AND BCMASK	;; select bytecode
	LSR		;; // 8 produces the table offset
	LSR
	LSR

.EXTD	TAX		;; code offset in A
	LDA BCTAB,X
	PHA		;; push codeptr
	+incr RW	;; advance instruction pointer

BCJUMP:
	PLA
	STA EV
	PLA
	JMP (EV)

BCNEXT:	
	+long
	LDA $0E		;; go to the next process
	TCD
	BRA BCDO
BCNEXT2:		;; a more convenient breakpoint
	BRA BCNEXT

BC_EXTD:
	;; can't happen
	;; this is handled above
	BRA BC_EXTD

BC_IVAR:
	;; 1X push instance variable
	+cells
	TAY
	LDA [RIV],Y
	+ipush
	JMP BCNEXT

BC_ARG:
	;; 2X push argument from context
	+cells
	TAY
	LDA (RCA),Y
	+ipush
	JMP BCNEXT
BC_TVAR:
	;; 3X push temp variable from context
	+cells
	TAY
	LDA (RCT)
	+ipush
	STA RA

BC_LITERAL:
	;; 4X push literal from 'interpreter'
	;; literals from source code are kept apart from bytecode
	+cells
	TAY
	LDA (RCC), Y
	+ipush
	JMP BCNEXT

;;;;;;;;;;;;;;;;;;;;
	O_TRUE	= $00F2
	O_FALSE	= $00F0
	O_NIL	= $00F4
	O_SMALLTALK = $00F6
	O_THISPROC = $00F8
BC5TAB:
	!word $0000, $0001, $0002, $0003
	!word $0004, $0005, $0006, $0007
	;; 8 9 -1 o_true
	!word $0008, $0009, $FFFF, O_TRUE
	;; o_false o_nil o_smalltalk o_thisproc
	!word O_FALSE, O_NIL, O_SMALLTALK, O_THISPROC
BC5MAX:
	!word $0010
BC5TABP:
	!word BC5TAB
;;;;;;;;;;;;;;;;;;;;

BC_CONSTANT:
	CMP BC5MAX
	BCC +
	JMP BCFAIL	;; we don't handle >= $10 (yet)
	;; map A to BCTAB
+	+cells
	CLC
	ADC BC5TABP
	STA RA
	LDA (RA)
	+ipush
	JMP BCNEXT
	
BC_PUSHBLOCK:
	BRA BC_PUSHBLOCK

BCIVAR_:
	;; pop, store in instance variable
	+cells
	TAY
	+ipop
	STA [RIV], Y
	JMP BCNEXT

BCTVAR_:
	+cells
	TAY
	+ipop
	STA (RCT), Y
	JMP BCNEXT

BC_MARK:	;; bytecode $09 10r09 MarkArguments
	;; collect arguments from stack into an array
	;; maybe reload context
	TAY	;; value (low)
	;LDA CONTEXT
	;+ipush
	TYA
	+ipush	;; i(size )
	+ipush	;; i(size size )
	JSR GCALLOC
		;; i(args size )
	INC
	INC
	STA RA
	;;LDA ArrayClass
	;;STA (RA)
	EOR RA	;; zero for now
	STA (RA)
	;; pop arguments from stack
	+ipop	;; args array
	STA RA
	+ipop	;; size in words
	ASL	;; words to bytes
	TAY
-	+ipop
	STA (RA),Y
	DEY
	DEY
	BPL -
	;; push arguments 
	LDA RA
	+ipop
	JMP BCNEXT


BC_SEND:
BC_SEND1:
BC_SEND2:
	JMP BCFAIL

BC_PRIMITIVE:	;; bytecode $0D 10r13 primitive
	JSR PRIMDO
	JMP BCNEXT
BC0E:
	JMP BCFAIL

BC_SPECIAL:	;; bytecode $0F 10r15 special
	;; action is based on value (A register)
	STZ RA
	INC RA	;; Special $01 SelfReturn
	CMP RA
	BNE +
	;; self return
	LDA [RIV]
	PHA
	JMP .RETURN
+	INC RA	;; Special $02 StackReturn
	CMP RA
	BNE +
	;; stack return
	+ipop
	PHA
	JMP .RETURN
+	INC RA ;; Special $03 BlockReturn
	CMP RA
	BNE +
	;; block return
	+ipop
	PHA
	;;;; return to creatingContext -> previousContext
	JMP .RETURN
+	INC RA ;; Special $04 Duplicate
	CMP RA
	BNE +
	;; duplicate
	+ipeek
	+ipush
	JMP BCNEXT
+	INC RA ;; Special $05 PopTop
	CMP RA
	BNE +
	;; PopTop aka drop
	DEC RS
	DEC RS
	JMP BCNEXT
+	INC RA ;; Special $06 Branch
	CMP RA
	BNE +
	;; branch (absolute)
	LDA (RW)
	STA RW
	JMP BCNEXT2
+	INC RA	;; Special $07 BranchIfTrue
	CMP RA
	BNE +
	;; branch if true
	+ipop
	CMP O_TRUE
	BNE .SKIP
	LDA (RW)
	STA RW
	JMP BCNEXT
+	INC RA	;; Special $08 BranchIfFalse
	CMP RA
	BNE +
	;; branch if false
	+ipop
	CMP O_FALSE
	BNE .SKIP
	LDA (RW)
	STA RW
	JMP BCNEXT
.SKIP:
	;; do not branch -- skip the failed branch address
	INC RW
	INC RW
	JMP BCNEXT

+	INC RA	;; Special $09 SendToSuper
	INC RA	;; Special $0A Breakpoint
	INC RA	;; OOPS
	BRK 
	BRK
	BRA BCFAIL
	

.RETURN:
	PLA
-	BRA -

BCFAIL:
	BRA BCFAIL

BCBOOT:	;; set up the VM, run BOOTSECTOR
	+long
	LDA BOOTSECTOR
	STA RW
	STZ RIV
	STZ RIV+2
	;; set O_TRUE and O_FALSE
	+const $1038
	STA O_FALSE
	+const $104a
	STA O_TRUE
	+const $00FF
	STA O_TRUE+2
	+const O_FALSE
	STA RCC
	+const $0080
	STA RS
	JMP BCDO

BOOTSECTOR:
	!word *+2
	!byte $50	;; push $0000	(dest databank)
	!byte $50	;; push $0000	(dest class)
	!byte $42	;; push BCC[2]	(size=$FF)
	!byte $D2, $07	;; <7 size class> new object
			;; i(dest dbank)
	!byte $51	;; push $0001	(src databank)
	!byte $58	;; push $0008	(src address)
	!byte $D2, $31	;; <16r31 src sbank dest dbank> objclone
	!byte $00, $00	;; stop here
	!byte $F6
	!word BOOTSECTOR+2
